<h1>Nim/Haxeの再探求 (2)</h1>
<p>投稿日: 2024/10/21 14:56:27</p>
<p>カテゴリ: 言語探求</p>
<p>サムネイル: なし</p><hr>

<p><a href="https://funatsufumiya.hatenablog.com/entry/2024/10/21/123944">前の記事</a>の続き。</p>
<p>前記事の最後に、<a href="https://www.beeflang.org/">Beef</a>という言語について取り上げて、元々この再探求のきっかけになった<a href="https://c3-lang.org/">C3言語</a>とも比較をしてみた。</p>
<p>簡単にいえば、C3は<a class="keyword" href="https://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC">C言語</a>との互換性を極力重視している一方、Beefは<a class="keyword" href="https://d.hatena.ne.jp/keyword/C%23">C#</a>と似た構文を持ちながらも<a class="keyword" href="https://d.hatena.ne.jp/keyword/C/C%2B%2B">C/C++</a>のような手動メモリ管理を取り入れている点がポイントといえる。</p>
<p>そこで改めてNim/<a class="keyword" href="https://d.hatena.ne.jp/keyword/Haxe">Haxe</a>と改めて比較してみると、自分はやはり、<a class="keyword" href="https://d.hatena.ne.jp/keyword/GC">GC</a>にメモリ管理を完全に委ねるのはかなり抵抗があるということに気付いた。ただ一方で、すべてを手動管理するというのもなかなか辛い。</p>
<p><a class="keyword" href="https://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>(11以降)がバランスが良いのは、基本的に手動のメモリ管理が可能でありながら、スマートポインタによる疑似<a class="keyword" href="https://d.hatena.ne.jp/keyword/GC">GC</a>（参照カウント操作）が可能という点。これはGodotが採用しているGDScriptとGDExtensionにもいえる。Godotの場合はRefCountクラスを継承したものは参照カウントで管理され、それ以外は手動メモリ管理になる。</p>
<p>自分はこれくらいのバランス感覚がちょうどいいかなと思っていて、Zigでも実は<a href="https://github.com/Aandreba/zigrc">zigrc</a>等を使えばできるのだけれど、普段から毎回アロケータを意識しなければいけないのはちょっと大変かなという気がする。もちろんZigの場合は隠された動作は極力しないという哲学があるのでシンプルで良いと思うけれど、自分はC3/Beefくらいの、必要なときだけカスタムアロケータを渡せたり、スタックアロケータは別で使える（C3でいうtalloc、Beefでいうscope）くらいが良いバランス感覚な気がする。</p>
<p>正直、必要なときだけ参照カウント（RefCount）が気軽に使える言語というのは、<a class="keyword" href="https://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>/(Godot)/Rustくらいしか自分は知らない。Zigはやっと最近前述の<a href="https://github.com/Aandreba/zigrc">zigrc</a>のようなライブラリが出てきたけれど、逆にいえばC3/Beefでも同様のスマートポインタやスマートクラス（あるいはカスタムアロケータ）を作ってしまえば良い気はするものの、それだと<a class="keyword" href="https://d.hatena.ne.jp/keyword/%BC%D6%CE%D8%A4%CE%BA%C6%C8%AF%CC%C0">車輪の再発明</a>をしてしまいがちなので、RustのRcのように標準ライブラリに入っていてほしい気もする。</p>
<p>…と、こんなノリで結局<a class="keyword" href="https://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>を使い続けてしまいながら、ざっと書きなぐるときは<a class="keyword" href="https://d.hatena.ne.jp/keyword/Python">Python</a>とかを使って結局最後に書き直す羽目になるので、もう少し調べて性に合う言語を見つけたい。</p>
<p>ちなみになぜ<a class="keyword" href="https://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>が嫌なのかといえば、ぶっちゃけ<a class="keyword" href="https://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>17に固定できるなら何も問題はないのだけれど、互換性の問題でそれ未満を使わなければならないケースは多くて、そうなるとOptionalすらstdになくてBoostを使ったりする羽目になるのが辛い。これはどの言語にもいえることかもしれないけれど、<a class="keyword" href="https://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>は依存関係が複雑であることが多いのでなかなか一筋縄ではいかない。</p>
<p>（余談として、この記事を書いたあとにBeefを試してみようとしたけれど、<a class="keyword" href="https://d.hatena.ne.jp/keyword/Apple">Apple</a> Silliconの<a class="keyword" href="https://d.hatena.ne.jp/keyword/Mac">Mac</a>はまだサポートされていない様子だったので<a href="https://github.com/beefytech/Beef/issues/2046">Issue</a>を立てた。良さそうな言語だったので使ってみたかったけれど、<a class="keyword" href="https://d.hatena.ne.jp/keyword/Apple">Apple</a> Sillicon <a class="keyword" href="https://d.hatena.ne.jp/keyword/Mac">Mac</a>がサポートされていないのは個人的につらすぎるので、Beefも見送りかなぁ。）</p>
