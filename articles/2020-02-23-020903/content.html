<p>『<a href="https://amzn.to/2PfQbhI">実践Rust入門</a>』読み終わって、実際に<a href="https://github.com/gfx-rs/gfx">gfx-hal</a>とか<a href="https://github.com/amethyst/rendy">rendy</a>とかいくつかレンダラー関係のプロジェクトを眺めてみて、いろんなことを考えた。</p>
<p>ちなみにこの書籍自体はちょっと構成が特殊で読みづらいのと、難易度がちょっと高い。でも中盤は図も豊富で読みやすいと思ったし、メモリ周りについての解説が特に豊富な印象だった。序盤をまるっと飛ばし読みして、Qiitaとかを併用して読めばちょうどいい入門書かなーと。</p>
<div class="amazlet-box" style="margin-bottom:0px;"><div class="amazlet-image" style="float:left;margin:0px 12px 1px 0px;"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/B07QVQ7RDG/mvnhatenadiar-22/ref=nosim/" name="amazletlink" target="_blank"><img src="https://images-fe.ssl-images-amazon.com/images/I/51t%2BhDKJOvL._SL160_.jpg" alt="実践Rust入門　[言語仕様から開発手法まで]" style="border: none;" /></a></div><div class="amazlet-info" style="line-height:120%; margin-bottom: 10px"><div class="amazlet-name" style="margin-bottom:10px;line-height:120%"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/B07QVQ7RDG/mvnhatenadiar-22/ref=nosim/" name="amazletlink" target="_blank">実践Rust入門　[言語仕様から開発手法まで]</a><div class="amazlet-powered-date" style="font-size:80%;margin-top:5px;line-height:120%">posted with <a href="http://www.amazlet.com/" title="amazlet" target="_blank">amazlet</a> at 20.02.22</div></div><div class="amazlet-detail"><a class="keyword" href="http://d.hatena.ne.jp/keyword/%B5%BB%BD%D1%C9%BE%CF%C0%BC%D2">技術評論社</a> (2019-04-26)<br />売り上げランキング: 25,694<br /></div><div class="amazlet-sub-info" style="float: left;"><div class="amazlet-link" style="margin-top: 5px"><a href="http://www.amazon.co.jp/exec/obidos/ASIN/B07QVQ7RDG/mvnhatenadiar-22/ref=nosim/" name="amazletlink" target="_blank">Amazon.co.jpで詳細を見る</a></div></div></div><div class="amazlet-footer" style="clear: left"></div></div>
<p>Rust言語について端的に言えば、低レイヤーなことを安全に高効率かつ高い記述力でやるとしたら、って考えた場合の<strong><a class="keyword" href="http://d.hatena.ne.jp/keyword/C%B8%C0%B8%EC">C言語</a>以外の新しい<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%D1%A5%E9%A5%C0%A5%A4%A5%E0">パラダイム</a></strong>だから、そもそも<a class="keyword" href="http://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>と比較すること自体がかなり難しいと思った。</p>
<p>Rustには<strong>可変長引数もなければ<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%D0%A1%BC%A5%ED%A1%BC%A5%C9">オーバーロード</a>もない</strong>し、継承も厳密には存在しないけど、それはRustでは<strong>特に問題にならない</strong>。何でもトレイトの記述力と<a class="keyword" href="http://d.hatena.ne.jp/keyword/%B4%D8%BF%F4%B7%BF%B8%C0%B8%EC">関数型言語</a>の強みで解決できちゃう。最初は<a class="keyword" href="http://d.hatena.ne.jp/keyword/Lisp">Lisp</a>並に記述力のあるマクロが多用されるのかと思ったけど、思ったほどは乱用されず、どのプロジェクトも可読性が高くてコードは綺麗だった。</p>
<p>一時期の<a class="keyword" href="http://d.hatena.ne.jp/keyword/Scala">Scala</a>のライブラリとかはすごく難解で読みにくくて、そういうことが起こりやすそうと思ってたけど、マクロさえ使いすぎなければ問題にならなそう。<strong><a class="keyword" href="http://d.hatena.ne.jp/keyword/%B4%D8%BF%F4%B7%BF%B8%C0%B8%EC">関数型言語</a>由来の難しさ</strong>についても、<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>みたいにうまいこと<strong>回避している</strong>なと思った。<a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>みたいに遅延評価とか<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%E2%A5%CA%A5%C9">モナド</a>とか理解する必要ないし、記法もそれほど<a class="keyword" href="http://d.hatena.ne.jp/keyword/%B4%D8%BF%F4%B7%BF%B8%C0%B8%EC">関数型言語</a>っぽくないし、強いて言えば所有権システムとトレイト境界が一瞬理解しづらいけど、個人的には<a class="keyword" href="http://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>の<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%C6%A5%F3%A5%D7%A5%EC%A1%BC%A5%C8%A5%E1%A5%BF%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0">テンプレートメタプログラミング</a>を理解 (&amp;<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%C7%A5%D0%A5%C3%A5%B0">デバッグ</a>) するのに比べれば簡単な気がした。</p>
<p>ということはRustの魅力はやっぱり<strong>ゼロコスト抽象化と所有権システム</strong> ( vs <a class="keyword" href="http://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>のスマートポインタ) といったところで、<a class="keyword" href="http://d.hatena.ne.jp/keyword/Microsoft">Microsoft</a>とかはそこ辺を高く評価して導入に踏み切ったんだと思う。あとはこの<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%D1%A5%E9%A5%C0%A5%A4%A5%E0">パラダイム</a>の大きな違いにどの程度慣れるかだと思う。</p>
<p>あとは、<strong><a class="keyword" href="http://d.hatena.ne.jp/keyword/IDE">IDE</a>がもう少し強化されて</strong>、<a class="keyword" href="http://d.hatena.ne.jp/keyword/%B4%D8%BF%F4%B7%BF%B8%C0%B8%EC">関数型言語</a>由来の部分が文化的にもう少し多くの人に理解されてくれば、もっとぐんと普及・導入されるのかなと思う。個人的には<a class="keyword" href="http://d.hatena.ne.jp/keyword/Scala">Scala</a>に対するKotlinみたいに、もっと<a class="keyword" href="http://d.hatena.ne.jp/keyword/%B4%D8%BF%F4%B7%BF%B8%C0%B8%EC">関数型言語</a>の部分をシンプルにした別言語が出てくる可能性もある気もするけど、Rust自体の難易度を評価するのは、<strong>マルチ<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%D1%A5%E9%A5%C0%A5%A4%A5%E0">パラダイム</a>過ぎて使う機能と用途に依る</strong>ので、一概には難しいなと思った。</p>
<p>自分個人としては、<a class="keyword" href="http://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>を書いていると時々Option型とかパターンマッチを使いたくなるので、<strong><a class="keyword" href="http://d.hatena.ne.jp/keyword/%B4%D8%BF%F4%B7%BF%B8%C0%B8%EC">関数型言語</a>の高い記述力</strong>が利用できるのがすごく魅力だと思った（<a class="keyword" href="http://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>でも出来なくもないんだけど、std::option型は<a class="keyword" href="http://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>17以前はexperimentalだし、関数型風な書き方は決まって読みづらくなる）。それとひょっとすると<a class="keyword" href="http://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>以外のユーザーにとっては、<strong>低レイヤーまわりと関数型の概念に入門しやすい言語</strong>なのかもと思った。結局Rustが理解しづらいのは<a class="keyword" href="http://d.hatena.ne.jp/keyword/C%2B%2B">C++</a>/<a class="keyword" href="http://d.hatena.ne.jp/keyword/Java">Java</a>に慣れてる場合だけだし、最初の言語がRustって人がいたら、いろんな<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%D1%A5%E9%A5%C0%A5%A4%A5%E0">パラダイム</a>に触れることができて結構幸せなのかもと思った。</p>
<p>ちなみにRustのグラフィック周りのライブラリを見た感じでは、低レイヤーについてはすごく完成度が高いけど、まだまだユーザが少ないのかハイレベルなデモが少ない印象。<strong>言語自体の難易度の高さ</strong>もあって、企業とかアーティストが参入しづらいんだろうけど、もっとユーザーが増えたらなと思った。この辺も<a class="keyword" href="http://d.hatena.ne.jp/keyword/IDE">IDE</a>と周辺ツールの完成度は影響しそう。</p>
<p>…とまあそんな感じで、全く違う<a class="keyword" href="http://d.hatena.ne.jp/keyword/%A5%D1%A5%E9%A5%C0%A5%A4%A5%E0">パラダイム</a>の言語を比較するってすごく難しいなぁと思った一日だった。でも、たまにはこうして新しい考え方を吸収するのも楽しい。</p>
